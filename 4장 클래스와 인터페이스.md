# 4장: 클래스와 인터페이스

### 아이템 15. 클래스와 멤버의 접근 권한을 최소화하라

- 잘 설계된 컴포넌트는 외부로부터 데이터와 내부 구현을 최소로 노출시킨다. 이를 통해 개발 속도 및 관리 비용의 효율화, 재사용성 향상 등 수많은 장점을 얻을 수 있다.
- 노출의 정도를 표현하는 기술적 메커니즘이 바로 접근 제한자이다. 모든 클래스, 멤버의 접근을 가능한 많이 좁히는 것이 기본 원칙이다.
- 특히 `public` 키워드를 통해 인스턴스 필드를 외부에 공개하는 것은 위험하다. 필드가 가변 상태인 경우 공유 자원처럼 동작하기 때문에 스레드로부터 안전하지 않다.

---

### 아이템 16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라

- 앞서 `public` 접근 제한자로 인스턴스 필드를 설정하지 말라고 했다. 대신 우린 해당 필드에 접근을 가능케 하는 메서드를 외부에 제공할 수 있다.
- 다만 접근자 메서드(예를 들어 lombok 패키지의 `@Getter` , `@Setter` 어노테이션)를 모든 객체마다 항상 추가하는 것은 사실상 필드를 `public` 상태로 두는 것과 크게 다르지 않다. 특히 필드를 변경하는 `setX` 메서드 등은 더욱 더 주의해야하며 만약 필요한 경우 명시적으로 사용되는 경우를 나타내도록 생성하자.

---

### 아이템 17. 변경 가능성을 최소화하라

- 클래스를 불변으로 만들기 위해선 어떻게 해야할까?
    - 객체의 상태를 변경하는 메서드를 제공하지 않습니다.
    - 하위 클래스에서 상태를 변경할 수 없도록 클래스를 확장 불가능하게 만듭니다. 일반적으로 클래스 생성시 `final` 키워드를 통해 상속이 불가능하도록 만들 수 있습니다.
    - 모든 필드를 `final` 키워드를 통해 불변으로 만듭니다. 배열과 같은 컬렉션 타입은 `final` 키워드로 선언해도 내부 요소에 접근할 수 있으니 주의해야 합니다.
    - 모든 필드를 `private` 으로 선언합니다. 위에 상태를 변경하는 메서드를 제공하지 않는 내용과 이어집니다.
    - 자신 외에는 내부 가편 컴포넌트에 접근하지 못하도록 만듭니다.
- 불변 객체는 단순합니다. 인스턴스화된 이 후 소멸될 때까지 상태를 항상 그대로 간직하기 때문이죠.
    - 이는 단순히 변하지 않는다는 것을 넘어 멀티스레드로 부터 발생하는 공유 자원에 대한 문제와 잦은 변경에 따른 버그 가능성도 줄여줍니다.
    - 하지만 항상 좋진 않습니다. 그 자체로 실패 원자성을 보장하긴 하지만 값이 변경될 때마다 새로운 객체를 생성해야 합니다. 그만큼 연산 비용을 소모한다는 것이기도 하죠.
    - 그럼에도 불구하고 우린 클래스는 일반적으로 불변으로 만드는 편이 좋습니다. 특정 상황에서의 성능 저하를 제외하곤 많은 장점을 갖고 있으니까요.
    - 저자는 ****************************다른 합당한 이유가 없다면 모든 필드는 `private` 이어야 한다** 고 말합니다.

---

### 아이템 18. 상속보다는 컴포지션을 사용하라

- 제목에 언급된 상속은 모든 종류의 상속을 의미하진 않는다. 여기선 일반적인 구체 클래스를 확장하는 구현 상속을 의미한다.
- 컴포지션을 통한 메서드 호출로 구현을 이어받는 것과 달리 **(구현)상속은 캡슐화를 깨뜨린다**는 치명적인 단점을 갖는다.
    - 예를 들어 `Stack` 클래스와 `Vector` 클래스 사이의 문제, `Properties` 와 `Hashtable` 사례가 있다.
    - 이를 피하는 가장 좋은 방법이 바로 **합성, Composition**이다.
- 구체 클래스를 확장하는 대신, 새로운 클래스를 만들고 `private` 필드로 기존 구체 클래스의 인스턴스를 참조하도록 하자.
    
    > *기존 클래스가 새로운 클래스의 구성요소로 쓰인다는 뜻에서 이러한 설계를 컴포지션(Composition; 구성)이라고 한다.*
    > 
    - 이 후 해당 기능이 필요하다면 새로운 클래스의 퍼블릭 인터페이스가 구체 클래스의 참조를 통해 메서드를 호출하도록 하면 위 문제가 해결된다.
    - 이로 인해 내부 구현의 영향에서 벗어날 수 있으며, 새로운 클래스에 메서드가 추가되어도 영향을 전혀 받지 않는다.

---