# 7장 : 람다와 스트림

### 아이템 42. 익명 클래스보다는 람다를 사용하라

- 이전엔 (추상 메서드를 하나만 가진 인터페이스인) 함수 객체의 인스턴스를 생성할 때 익명 클래스를 사용했다. 하지만 Java 1.8이 나온 뒤엔 람다를 사용할 수 있다. 사용하라.
- 불필요한 코드(인스턴스 생성 코드)가 사라지며 어떤 동작을 수행하는지만 남아 가독성 측면에서 좋다.
- 타입을 명시하는 것이 가독성에 도움이 되지 않는다면 생략하자.
- 조심해야할 것이 있다. 람다는 익명 함수이므로 문서화가 불가능하다. 코드가 너무 길어져 동작을 알아보기 어렵거나 코드 줄 수가 늘어난다면 사용하지 말자.
    - 이럴 땐 클래스를 정의하라.
- 직렬화는 절대 금지다.

### 아이템 43. 람다보다는 메서드 참조를 사용하라

- 메서드 참조를 사용해 불필요한 인자 명시를 없애고 동작을 메서드명으로 표현할 수 있다.
    - 하지만 메서드 참조가 너무 길어 오히려 가독성에 방해가 된다면 차라리 람다를 사용하는 것이 낫다.
- 메서드 참조에는 다섯가지 유형이 존재한다.
    
    ```java
    // Method References Types
    // 1. 정적
    Integer::parseInt
    
    str -> Integer.parseInt(str)
    
    // 2. 한정적(인스턴스)
    Instant.now()::isAfter
    
    Instant then = Instant.now();
    t -> then.isAfter(t);
    
    // 3. 비한정적(인스턴스)
    String::toLowerCase
    
    str -> str.toLowerCase()
    
    // 4. 클래스 생성자
    TreeMap<K,V>::new
    
    () -> new TreeMap<K,V>()
    
    // 5. 배열 생성자
    int[]::new
    
    len -> new int[len]
    ```

### 아이템 44. 표준 함수형 인터페이스를 사용하라

- 굳이 직접 만들지말고 표준 함수형 인터페이스를 사용하자.
- 만약 직접 만들었다면 항상 @FunctionalInterface 어노테이션을 사용하자.

### 아이템 45. 스트림은 주의해서 사용하라

- 스트림은 좋다. 하지만 과도하게 사용한다면 오히려 유지보수성이 떨어진다.
- 스트림 사용 시의 람다 내에 인자 이름은 잘 지어야 한다. 함부로 생략하면 스트림 파이프라인의 가독성이 떨어진다.
    - 람다 내 세부 동작도 메서드 추출로 간략하게 표현해 가독성을 높이자.
- 모든 반복 로직을 스트림으로 처리하려는 유혹을 떨쳐내라.

### 아이템 46. 스트림에서는 부작용(사이드 이펙트) 없는 함수를 사용하라

- 스트림 패러다임의 핵심은 **계산을 일련의 변환으로 재구성**하는 것이다.
    - 변환 단계는 이전 단계의 결과를 받아 처리하는 순수 함수(스스로 다른 상태를 변경하지 않고 입력만이 결과의 영향을 주는 함수)여야 한다.
    - 이는 모든 함수 객체가 사이드 이펙트가 없어야 한다는 의미다.
- forEach 연산은 스트림 계산 결과를 보고할 때만 사용하고, 계산할 땐 사용하지 마라.
