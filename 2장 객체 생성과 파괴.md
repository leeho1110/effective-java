# 2장: 객체 생성과 파괴

### 개요

이번 장에서는 언제 객체를 만들지 혹은 만들지 말아야할지를 다룹니다. 만약 생성한다면 어떻게 올바르게 생성할 수 있는지도 다룹니다.

---

### 아이템 1. 생성자 대신 정적 팩터리 메서드를 고려하라

- 무작정 public 생성자를 사용할 때 발생하는 단점들을 정적 팩토리 메서드를 통해 해결합니다.
    - public 생성자는 이름을 가질 수 없기 때문에 반환 객체의 특성을 적절히 설명하지 못합니다. 정적 팩토리 메서드는 이름을 통해 특성 묘사가 가능합니다.
    - `Boolean.valueOf(boolean)` 메서드처럼 만들어놓은 인스턴스를 캐싱하는 형태를 통해 인스턴스 생성 부담을 줄일 수 있습니다.
    - 객체지향의 다형성을 활용해 반환하고자 하는 하위 타입의 반환이 가능합니다. 파라미터에 따라 다른 내부 동작을 구현해 다른 클래스 인스턴스 반환이 가능합니다.
        - 내부 구현을 노출하지 않아도 됩니다.
    - 메서드의 작성 시점에는 구현체 클래스가 생성 시점에 존재하지 않아도 됩니다.
        - 생성자의 경우 생성 타입이 컴파일 시점에 정해지지만, 정적 팩토리 메서드는 위에 언급된 내용처럼 타입을 동적으로 결정해 반환할 수 있습니다.
- 하지만 단점도 존재합니다.
    - public 생성자없이 정적 팩토리 메서드만 제공하는 경우 상속이 불가능합니다.

---

### 아이템 2. 생성자에 매개변수가 많다면 빌더를 고려하라

- 정적 팩토리 메서드와 생성자 모두 매개변수가 많은 경우 클라이언트 가독성이 떨어집니다. 매개변수들 중 다수가 선택적이고 같은 타입인 경우라면 더더욱 빌더 패턴을 고려하는 것이 좋습니다.

---

### 아이템 3. private 생성자나 열거 타입으로 싱글턴임을 보증하라

- public static final 필드를 private 생성자를 통해 최초 초기화하면 이 후 클라이언트 객체는 신규 객체 생성이 불가능합니다.
    - 하지만 Reflection을 통한 priavte 생성자 호출은 방어가 불가능합니다. 따라서 완벽한 싱글톤 인스턴스가 보장되진 않습니다.
    - 이 경우는 생성자 수정을 통해 두 번째 객체가 생성되려할 때 예외를 발생시키는 방법으로 해결이 가능합니다.

---

### 아이템 4. 인스턴스화를 막으려거든 private 생성자를 사용하라

---

### 아이템 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라

- 클래스 여러 자원을 의존하는 경우라면 내부적으로 자원을 명시하는 것은 변경에 유연하게 대처할 수 없다. 이 경우 인스턴스를 생성할 때 필요한 자원을 넘겨주는 **의존 객체 주입** 방식을 사용하는 것이 좋다.
- 본문에선 의존 주입 프레임워크 중 하나로 Spring을 소개한다. 누군가 왜 Spring Framework를 사용하냐고 묻는다면 **편리한 의존성 주입**이라고 대답할 수 있다.

---