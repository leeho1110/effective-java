# 8장 : 메서드

### 아이템 49. 매개변수가 유효한지 검사하라

- 특정 메서드를 시작할 때 매개변수를 사용한다면, 반드시 구현 시작부에서 이를 검증하라. 오류는 반드시 발생한 즉시 빠르게 확인하고 처리하는 것이 좋다.

---

### 아이템 50. 적시에 방어적 복사본을 만들라

- 우리가 처음 프로그래밍을 할 때 모든 코드를 자신이 제어할 수 있다고 믿는 경우가 종종 있다. 난 그랬었다. 하지만 메서드와 클래스를 정의할 땐 항상 이를 호출하는 클라이언트는 내가 아닌 다른 사람이라고 가정해야 한다. 본문에서도 이렇게 말한다.
    
    > *클라이언트가 여러분의 불변식을 깨뜨리려 혈안이 되어 있다고 가정하고 방어적으로 프로그래밍해야 한다.*
    > 
    - 내부에서 어떤 객체를 수정하는 행위는 생각보다 많은 버그를 가져올 수 있다. 불변 객체를 이용하는 이유는 예상치 못한 변경에 의한 버그를 막기 위해서이기도 하다.
        - `Date` 와 같은 클래스의 경우 `LocalDataTime`, `Instant`, `ZondedDateTime` 와 같은 불변 클래스를 통해 개선할 수 있다.
    - 만약 클라이언트의 불변을 깨뜨리고자 하는 위험을 막고 싶다면 **매개변수를 방어적으로 복사한 뒤 유효성 검사를 진행**하면 된다. 방어적 복사를 사용하는 이유는 원본 객체로 진행할 경우 수정과 유효성 검사를 각각 다른 스레드가 수행하며 순서가 얽히는 동시성 문제가 존재하기 때문이다.
- 즉 클래스가 클라이언트로부터 가져오거나 반환하는 요소가 가변 상태라면 ‘반드시’ 방어적 복사를 진행해야 한다. 이 때 비용이 너무 크다면 요소의 변경으로 인한 책임이 클라이언트에게 있음을 문서로 명시하자.

---

### 아이템 51. 메서드 시그니처를 신중히 설계하라

- 메서드 이름을 신중히 짓자. 본인만 사용하는 코드가 아니다.
- 편의 메서드를 너무 많이 만들지 말고, 매개변수 목록을 짧게 유지하자.
    - 가변 컨텍스트 객체를 활용해 매개변수 타입을 하나로 정의하는 경우가 있는데, 이 경우 해당 컨택스트에 대한 의존도가 매우 높아진다. 메서드 내에서 사용할 요소들만 별도로 나눠서 정의하자.
- 만약 요소들이 너무 많다면 함수를 제대로 쪼개지 못했는지 확인하자. 그래도 너무 많다면 매개변수를 묶는 도우미 클래스를 정적 멤버 클래스로 정의하자.
- 매개변수의 타입은 클래스보단 인터페이스가 낫다.
- `boolean` 타입의 매개변수보다 원소 2개짜리 열거 타입이 낫다. 공감한다.

---

### 아이템 52. 다중정의는 신중히 사용하라

```java
public class CollectionClassifier {
    public static String classify(Set<?> s) {
        return "집합";
    }

    public static String classify(List<?> lst) {
        return "리스트";
    }

    public static String classify(Collection<?> c) {
        return "그 외";
    }

    public static void main(String[] args) {
        Collection<?>[] collections = {
                new HashSet<String>(),
                new ArrayList<BigInteger>(),
                new HashMap<String, String>().values()
        };

        for (Collection<?> c : collections)
            System.out.println(classify(c));
    }
}
```

- 위 코드에서 `classifiy` 메서드는 ‘그 외’를 3번 출력한다. 오버로딩된 메서드는 컴파일 타임에 어느 메서드를 호출할지 결정하고, 오버라이딩은 런타임에 이를 결정한다.
    - `classify` 는 매개변수만 타입이 다른 오버로딩된 메서드. `collection` 변수에 각각 `HastSet`, `ArrayList`, `HashMap` 인스턴스가 들어가있긴 하지만 타입은 `Collection` 타입이다.
    - 이 문제를 해결하기 위해선 매개변수가 같은 오버로딩은 피하는 것이 좋다. 메서드 이름을 다르게 지어주는 방식으로도 충분히 해결이 가능한 문제이기 때문이다.

---

### 아이템 53. 가변인수는 신중히 사용하라

- 가변인수는 인수의 개수가 정해지지 않았을 때 유용하게 사용될 수 있다. 하지만 메서드 내에서 인수를 반드시 하나 이상 필요로 할 때, 0개를 넣어도 컴파일 타임엔 빌드가 정상적으로 진행되며 런타임에서 문제가 발생한다.

---